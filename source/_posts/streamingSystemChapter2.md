---
title: 《Streaming System》-第二章： 数据处理的什么、何地、何时以及如何进行
date: 2000-03-17 22:07:43
tags: 
  - Streaming System
categories: 
  - Streaming System
---

<p></p>
<!-- more -->

## 目录
<!-- toc -->

# 路线图

为了帮助为本章打下基础，我想提出五个主要概念，这些概念将支撑所有讨论，以及大部分第一部分的内容。我们已经讨论了其中两个。

在第一章中，我首先建立了事件时间（事件发生的时间）和处理时间（在处理期间观察到的时间）之间的关键区别。这为本书提出的一个主要论点奠定了基础：如果您关心正确性和事件实际发生的上下文，则必须相对于它们固有的事件时间而不是在分析过程中遇到它们的处理时间来分析数据。

然后，我介绍了*窗口化*的概念（即沿着时间边界对数据集进行分区），这是一种常用的方法，用于应对无限数据源在技术上可能永远不会结束的事实。窗口化策略的一些更简单的例子是*固定*和*滑动*窗口，但更复杂的窗口化类型，例如*会话*（其中窗口是由数据本身的特征定义的;例如，捕获用户的每个活动会话，然后是不活动的间隙），也广泛使用。

除了这两个概念之外，我们现在将仔细研究另外三个概念：

- 触发器 Triggers

  触发器是用于声明与某些外部信号相对应的窗口输出应该实现的机制。触发器提供了选择何时发出输出的灵活性。在某种意义上，您可以将它们视为用于指示何时应该实现结果的流量控制机制。另一种看待它的方式是，触发器就像相机的快门释放，允许您在计算结果的时间中声明何时拍摄时间快照。

  触发器还使得可以多次观察窗口输出随着时间的推移而演变。这反过来打开了随着时间推移细化结果的大门，这允许在数据到达时提供推测结果，以及处理上游数据（修订）随着时间或到达晚（例如，在离线时手机记录各种操作及其事件时间，然后在重获连接时上传这些事件以进行处理）。

- 水印 Watermarks

  水印是相对于事件时间的输入完整性的概念。具有时间 *X* 值的水印表明：“事件时间小于*X*的所有输入数据都已被观察到。”因此，水印在观察没有已知结束的无限数据源时作为进度的指标。我们在本章中介绍了水印的基础知识，然后Slava在第3章中深入探讨了这个主题。

- 累积 Accumulation

  累积模式指定了观察到同一窗口的多个结果之间的关系。这些结果可能完全分离;也就是说，代表随时间独立的增量，或者它们之间可能存在重叠。不同的累积模式具有不同的语义和相关成本，因此在各种用例中找到了应用。

此外，因为我认为这使得更容易理解所有这些概念之间的关系，我们重新审视了旧的并在回答四个问题的结构内探索了新的，我提出这些问题对于每个无限数据处理问题都至关重要：

- 计算出什么结果？这个问题由管道内的转换类型回答。这包括像计算总和、构建直方图、训练机器学习模型等内容。它基本上也是*批处理的常见问题回答的问题*。
- 在什么事件时间计算结果？这个问题由管道内的事件时间窗口化回答。这包括第1章中的常见窗口化示例（固定、滑动和会话），似乎没有窗口化概念的用例（例如，时间不受限制的处理；经典批处理也通常属于此类别）以及其他更复杂的窗口化类型，例如时间限制的拍卖。还要注意，如果将记录的入口时间分配为到达系统时的事件时间，则也可以包括处理时间窗口化。
- 何时在处理时间中实现结果？这个问题是通过触发器和（可选的）水印来回答的。对此主题有无限变化，但最常见的模式是涉及重复更新的模式（即，实现视图语义），利用水印为每个窗口提供单个输出，仅在相应的输入被认为是完整的后才提供（即，应用于每个窗口的经典批处理语义），或两者的某种组合。
- 如何处理结果的细化？这个问题是由使用的累积类型回答的：丢弃（其中结果是所有独立和独特的），累积（其中后来的结果建立在先前的结果之上），或累积和撤回（其中发出累积值加上先前触发的值的撤回）。

我们在本书的其余部分中更详细地研究了这些问题。是的，我将尝试将这个颜色方案运用到底，以尝试清晰地表明哪些概念与*What/Where/When/How*习语中的哪些问题有关系。你是受欢迎的 ` <winky smiley/>`。 



#  批处理基础知识：什么  和  何地

好的，让我们开始吧。首先，是批处理。

###  *什么*：转换

经典批处理中应用的转换回答了这个问题：

“计算出了***什么***结果？”尽管你可能已经熟悉经典批处理，但我们还是要从这里开始，因为它是我们添加所有其他概念的基础。

在本章的其余部分（事实上，在本书的很大一部分中），我们将看到一个单一的示例：在由九个值组成的简单数据集上计算有键整数总和。

假设我们编写了一个团队游戏，并且我们想要构建一个管道，通过总结用户手机报告的个人分数来计算团队分数。如果我们将我们的九个示例得分捕获在名为“UserScores”的SQL表中，它可能看起来像这样：

---

|名称|团队|分数|事件时间|ProcTime|

---

|朱莉|TeamX|5|12:00:26|12:05:19|

|弗兰克|TeamX|9|12:01:26|12:08:19|

|爱德华|TeamX|7|12:02:26|12:05:39|

|朱莉|TeamX|8|12:03:06|12:07:06|

|艾米|TeamX|3|12:03:39|12:06:13|

|弗雷德|TeamX|4|12:04:19|12:06:39|

|纳奥米|TeamX|3|12:06:39|12:07:19|

|贝基|TeamX|8|12:07:26|12:08:39|

|纳奥米|TeamX|1|12:07:46|12:09:00|

---

请注意，此示例中的所有分数都来自同一团队的用户；这是为了保持示例简单，因为我们的图表中有限的维数数量。因为我们正在按团队分组，所以我们只关心最后三列：

- 分数

  与此事件相关联的单个用户分数

- EventTime

  得分的事件时间；即得分发生的时间

- ProcTime

  得分的处理时间；即管道观察到得分的时间

对于每个示例管道，我们将查看一个时间演变图，该图突出显示数据随时间的演变方式。这些图将我们的九个分数绘制在我们关心的两个时间维度上：x轴上的事件时间和y轴上的处理时间。图2-1说明了输入数据的静态绘图效果。

{% asset_img  stsy_0201.png  %}
*图2-1.在事件时间和处理时间中绘制的九个输入记录*

随后的时间演变图是动画（Safari）或一系列帧（打印和所有其他数字格式），可以让您看到数据随时间的处理方式（在我们到达第一个时间演变图之后不久，我们会详细介绍这一点）。

在每个示例之前，都有一个Apache Beam Java SDK伪代码的简短片段，以使管道定义更具体。它是伪代码，因为我有时会弯曲规则以使示例更清晰，省略细节（如使用具体I / O源），或简化名称（Beam Java 2.x及更早版本的触发器名称过长；我使用更简单的名称来清晰起见）。除了像这样的小事情之外，它是真实的Beam代码（本章中所有示例的真实代码都可在GitHub上找到）。

如果您已经熟悉像Spark或Flink这样的东西，您应该很容易理解Beam代码正在做什么。但是，为了让您快速了解，Beam有两个基本原语：

- PCollections

  这些表示可以执行并行转换的数据集（因此名称的开头有“P”）。

- PTransforms

  这些应用于PCollections以创建新的PCollections。

  PTransforms可以执行逐个元素的转换，它们可以将多个元素分组/聚合在一起，或者它们可以是其他PTransforms的组合，如图2-2所示。

{%  asset_img  stsy_0202.png  %}
*图2-2.转换类型*

对于我们的示例，我们通常假设我们从预加载的PCollection<KV<Team，Integer>>“input”（即由Team和Integers组成的键/值对的PCollection，其中Teams仅是表示团队名称的字符串，而Integers是来自相应团队的任何个人的分数）开始。在实际的管道中，我们将通过从I / O源读取原始数据（例如，日志记录）的PCollection<String>并将其转换为PCollection<KV<Team，Integer>>来获取输入。通过将日志记录解析为适当的键/值对。为了在这个第一个示例中清楚起见，我包括了所有这些步骤的伪代码，但在接下来的示例中，我省略了I / O和解析。

因此，对于一个简单地从I / O源读取数据，解析团队/分数对并计算每个团队的总分的管道，我们将有像示例2-1中所示的那样的东西。

*示例2-1.总和管道*
```
PCollection<String> raw = IO.read（...）;
PCollection<KV<Team，Integer>> input = raw.apply（new ParseFn（））;
PCollection<KV<Team，Integer>> totals =
  input.apply（Sum.integersPerKey（））;
```
从I / O源读取键/值数据，其中Team（例如，团队名称的字符串）作为键，Integer（例如，对应团队成员的分数）作为值。然后将每个键的值相加以生成每个键的总和（例如，团队总得分）在输出集合中。

在接下来的所有示例中，看到描述我们正在分析的管道的代码片段后，我们将查看一个时间演变图，显示该管道在单个键的具体数据集上的执行。在实际管道中，您可以想象类似的操作会在多台机器上并行发生，但是为了简单起见，在我们的示例中将更清晰。

如前所述，Safari版本将完整执行作为动画电影呈现，而打印和所有其他数字格式使用一系列静态关键帧序列，这些关键帧提供了管道如何随时间推移的进展的感觉。在这两种情况下，我们还提供指向*[www.streamingbook.net](http://www.streamingbook.net/)*上完全动画版本的URL。

每个图表在两个维度上绘制输入和输出：事件时间（x轴）和处理时间（y轴）。因此，由管道观察到的实时时间从底部向上推进，如处理时间轴中上升的粗黑线所示。输入是圆圈，圆圈内的数字表示特定记录的值。它们开始是浅灰色的，并随着管道观察到它们而变暗。

当管道观察到值时，它会在其中间状态中累积它们，并最终将聚合结果实现为输出。状态和输出由矩形表示（灰色为状态，蓝色为输出），聚合值靠近顶部，并且由矩形覆盖的区域表示积累到结果的事件时间和处理时间的部分。对于示例2-1中的管道，在经典批处理引擎上执行时，它看起来像图2-3所示。

{% dplayer "url=stsy_0203.mp4" %} 
*图2-3.经典批处理*

因为这是批处理管道，所以它会累积状态，直到看到所有输入为止（由顶部的虚线绿线表示），此时它会产生其单个输出为48。在这个示例中，我们正在计算事件时间的所有总和，因为我们没有应用任何特定的窗口转换；因此，状态和输出的矩形覆盖了整个x轴。但是，如果我们想要处理无限数据源，则经典批处理将不足够；我们无法等待输入结束，因为它实际上永远不会结束。我们想要的概念之一是窗口，这是我们在第1章中介绍的。因此，在我们的第二个问题“事件时间的***哪里***计算结果？”的上下文中，我们现在将简要重新访问窗口。

###   何地：窗口

如第1章所述，窗口是沿时间边界切分数据源的过程。常见的窗口策略包括固定窗口、滑动窗口和会话窗口，如图2-4所示。

{% asset_img stsy_0204.png %}
*图2-4.示例窗口策略。每个示例均显示为三个不同的键，突出显示对齐窗口（适用于所有数据）和不对齐窗口（适用于数据子集）之间的差异。*

为了更好地了解窗口在实践中的样子，让我们将我们的整数求和管道窗口化为固定的两分钟窗口。通过Beam，更改是将Window.into变换添加到您可以在示例2-2中看到的地方。

*示例2-2.分段求和代码*
```
PCollection<KV<Team，Integer>> totals = input
  .apply（Window.into（FixedWindows.of（TWO_MINUTES）））
  .apply（Sum.integersPerKey（））;
```
请记住，Beam提供了一个统一的模型，可以在批处理和流处理中使用，因为从语义上讲，批处理实际上只是流处理的一个子集。因此，让我们首先在批处理引擎上执行此管道；机制更加简单，当我们切换到流引擎时，它将为我们提供直接比较的内容。图2-5呈现了结果。

{% dplayer "url=stsy_0205.mp4" %} 
*图2-5.在批处理引擎上的分段求和*

与以前一样，输入会在状态中累积，直到完全消耗，此后才会产生输出。但是，在这种情况下，我们不仅仅得到一个输出，而是得到四个输出：每个相关的两分钟事件时间窗口的单个输出。

到目前为止，我们已经重新访问了我在第1章中介绍的两个主要概念：事件时间和处理时间域之间的关系以及窗口。如果我们想继续，我们将需要开始添加本节开头提到的新概念：触发器、水印和累积。


#  流计算：何时  和  如何转换

我们刚刚观察了批处理引擎上窗口化管道的执行情况。

但是，理想情况下，我们希望在结果方面具有较低的延迟，并且我们还希望本地处理未限定的数据源。切换到流媒体引擎是朝着正确方向迈出的一步，但是我们以前的策略是等待输入已完全消耗以生成输出，这是不可行的。然后进入触发器和水印。

### *何时*：关于触发器的美妙之处

### 就是触发器是美妙的东西！

触发器提供了答案：在处理时间中“***何时***” 来实现结果材料化。触发器声明何时在处理时间中应该发生窗口的输出（尽管触发器本身可能基于发生在其他时间域（例如事件时间域中进行的水印进展）的事情做出这些决定，正如我们将在接下来的几个时刻中看到的）。每个窗口的特定输出称为窗格。

虽然可以想象出相当广泛的可能触发语义，但在概念上只有两种通常有用的触发器类型，实际应用几乎总是使用其中一种或两种的组合：

- 重复更新触发器

  这些定期根据其内容生成窗口的更新窗格。这些更新可以随着每个新记录实现，也可以在一些处理时间延迟之后实现，例如每分钟一次。重复更新触发器的周期选择主要是权衡延迟和成本的一种方法。

- 完整性触发器

  这些仅在对该窗口的输入被认为已完成到某个阈值时才材料化该窗格。这种类型的触发器最类似于我们在批处理中熟悉的内容：仅在输入完成后，我们才提供结果。触发器基于方法的不同之处在于完整性的概念仅限于单个窗口的上下文，而不总是与整个输入的完整性相关联。

重复更新触发器是流式系统中最常见的触发器类型。它们易于实现，易于理解，并为特定类型的用例提供有用的语义：对材料化数据集的重复（并最终一致）更新，类似于数据库世界中材料化视图所得到的语义。

完整性触发器很少遇到，但提供与经典批处理世界中更相似的流式语义。它们还提供了用于推理诸如缺失数据和延迟数据之类的事物的工具，我们很快就会讨论（并在下一章中）当我们探索驱动完整性触发器的基础原语时：水印。

但首先，让我们从简单的方面入手，看看一些基本的重复更新触发器的操作。为了使触发器的概念更加具体化，让我们继续向我们的示例管道添加最简单的触发器类型：每次新记录都会触发的触发器，如示例2-3所示。

*示例2-3。每个记录都会重复触发*
```
PCollection<KV<Team，Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))
               .triggering(Repeatedly(AfterCount(1))));
  .apply(Sum.integersPerKey());
```
如果我们在流式引擎上运行这个新管道，结果会像图2-6所示。



{% dplayer "url=stsy_0206.mp4" %} 

*图2-6.在流媒体引擎上每条记录触发*

您可以看到我们现在为每个窗口获得多个输出（窗格）：每个对应输入的一次。当输出流被写入某种表以便您可以简单地轮询结果时，这种触发模式工作得很好。每当您查看表时，您将看到给定窗口的最新值，这些值随着时间的推移会趋于正确。

单个记录触发的一个缺点是它非常繁琐。在处理大规模数据时，聚合（例如求和）提供了一个很好的机会，可以在不丢失信息的情况下减少流的基数。这对于具有高交易量密钥的情况特别明显；对于我们的示例，具有许多活动玩家的大型团队。想象一下一个大规模的多人游戏，其中玩家被分为两个阵营，并且您想按阵营基础上统计统计数据。对于给定阵营中的每个玩家的每个新输入记录更新您的统计数据可能是不必要的。相反，您可能会满意地在一些处理时间延迟之后进行更新，例如每秒或每分钟。使用处理时间延迟的好处是，它对高交易量键或窗口具有均等化效应：由此产生的流在基数方面最终会更加统一。

触发器中的处理时间延迟有两种不同的方法：*对齐延迟*（其中延迟将处理时间切片为在键和窗口之间对齐的固定区域）和*不对齐延迟*（其中延迟相对于在给定窗口中观察到的数据）。具有不对齐延迟的管道可能类似于Beam中的示例2-4，其结果如图2-7所示。

*示例2-4。在对其的两分钟处理时间边界上触发*
```
PCollection<KV<Team，Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))
               .triggering(Repeatedly(AlignedDelay(TWO_MINUTES)))
  .apply(Sum.integersPerKey());
```


{% dplayer "url=stsy_0207.mp4" %} 

*图2-7。两分钟对齐延迟触发器（即，微批处理）*

这种对齐延迟触发器实际上类似于Spark Streaming之类的微批处理流系统。它的好处在于可预测性;您在相同时间内获得所有修改的窗口的定期更新。这也是缺点：所有更新都同时发生，这会导致爆发式的工作负载，通常需要更大的峰值配额来正确处理负载。另一种选择是使用不对齐的延迟。这在Beam中可能类似于示例2-5，其结果如图2-8所示。

*示例2-5。在两分钟的不对齐处理时间边界上触发*
```
PCollection<KV<Team，Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))
               .triggering(Repeatedly(UnalignedDelay(TWO_MINUTES))
  .apply(Sum.integersPerKey());
```



{% dplayer "url=stsy_0208.mp4" %} 

*图2-8。两分钟不对齐延迟触发器*

将图2-8中的不对齐延迟与图2-6中的对齐延迟进行对比，可以很容易地看出不对齐延迟如何更均匀地分布负载。对于任何给定窗口涉及的实际延迟在两者之间有所不同，有时更多，有时更少，但最终平均延迟将基本保持不变。从这个角度来看，对于大规模处理，不对齐的延迟通常是更好的选择，因为它们会导致时间上更均匀的负载分布。

重复更新触发器非常适合我们只想要随着时间的推移定期更新结果的用例，并且对于这些更新收敛到正确性并没有明确的指示的情况感到满意。但是，如我们在第1章讨论的那样，分布式系统的不确定性通常会导致事件发生的时间与您的管道实际观察到该事件的时间之间的变化程度不同，这意味着很难理解您的输出何时提供了输入数据的准确和完整视图。对于重视输入完整性的情况，重要的是有某种方法来推理完整性，而不是盲目地信任哪个子集的数据已经流到您的管道中。然后进入水印。



###  **何时：水印**

水印是回答“处理时间何时实现结果”的问题的一个支持方面。水印是输入完整性在事件时间域中的时间概念。换句话说，它们是系统相对于正在处理的事件流记录的事件时间测量进度和完整性的方式（有界或无界的情况下都很有用，但在无界的情况下它们更明显）。

回想一下第一章中的这个图表，在图2-9中稍作修改，我将事件时间和处理时间之间的偏差描述为大多数实际分布式数据处理系统中时间的不断变化的函数。



{% asset_img  stsy_0209.png  %}

*图2-9. 事件时间进度，偏差和水印*

我声称代表现实的那条蜿蜒的红线本质上是水印；它捕获事件时间完整性随着处理时间的推进的进展。在概念上，您可以将水印视为一个函数，*F*(*P*)→*E*，它将处理时间中的一个点返回到事件时间中的一个点。事件时间中的那个点，*E*，是系统认为已经观察到了所有事件时间小于*E*的输入的点。换句话说，它是一个断言，即不会再看到事件时间小于*E*的更多数据。根据水印的类型，完美或启发式，该断言可以是严格保证或有教养的猜测。

- 完美水印

  对于我们拥有所有输入数据的情况，可以构建完美的水印。在这种情况下，不存在延迟数据；所有数据都是提前或准时的。

- 启发式水印

  对于许多分布式输入源，实际上不可能完全了解输入数据，因此提供启发式水印是下一个最佳选择。启发式水印使用有关输入的任何信息（分区、如果有的话，分区内的排序、文件的增长率等），以提供尽可能准确的进度估计。在许多情况下，这样的水印可以令人惊讶地准确预测。即便如此，使用启发式水印意味着它有时可能是错误的，这将导致延迟数据。我们很快就会向您展示处理延迟数据的方法。

因为它们提供了相对于我们的输入的完整性概念，水印是前面提到的第二种触发器的基础：完整性触发器。水印本身是一个非常有趣和复杂的话题，当您到达第3章的Slava的水印深度探索时，您就会看到。但是，现在让我们通过更新我们的示例管道以利用基于水印的完整性触发器来看看它们的实际应用，如示例2-6所示。

*示例2-6. 水印完整性触发器*
```
PCollection<KV<Team, Integer>> totals = input
  .apply(Window.into(FixedWindows.of(TWO_MINUTES))
              .triggering(AfterWatermark()))
  .apply(Sum.integersPerKey());
```
水印的一个有趣的特点是它们是一类函数，这意味着有多个不同的函数*F*(*P*)→*E*满足水印的属性，成功程度不同。正如我之前所指出的，对于您拥有输入数据的情况，可能可以构建完美的水印，这是理想的情况。但是对于缺乏输入的完美知识或计算完美水印的计算成本太高的情况，您可能会选择使用启发式来定义您的水印。我想在这里强调的一点是，使用的水印算法独立于管道本身。我们不会在这里详细讨论实施水印的含义（Slava在第3章中介绍），但是为了帮助加强这个想法，即一组给定的输入可以应用不同的水印，让我们看一下在相同的数据集上运行示例2-6的管道，但使用两个不同的水印实现（图2-10）：在左侧，完美的水印；在右侧，启发式水印。

在两种情况下，窗口在水印通过窗口结束时实现。如您所预期的，完美水印完美地捕获了管道随着时间的推移的事件时间完整性。相比之下，右侧启发式水印使用的特定算法未考虑9的值，这大大改变了材料化输出的形状，无论是在输出延迟还是正确性方面（如为[12:00,12:02)窗口提供的不正确答案5所示）。水印触发器与图2-9中所示的重复更新触发器之间的最大区别是，水印使我们有一种方法来推断我们的输入的完整性。在系统为给定窗口实现输出之前，我们知道系统尚未认为输入已完成。这对于希望推断输入中缺少数据或缺少数据的用例尤其重要。


{% dplayer "url=stsy_0210.mp4" %} 
*图2-10. 具有完美（左）和启发式（右）水印的流式引擎上的窗口求和*

缺少数据用例的一个很好的例子是外连接。没有像水印这样的完整性概念，您如何知道何时放弃发出部分连接而不是继续等待该连接完成？你不知道。在缺乏真正的水印支持的流式系统中，将该决定基于处理时间延迟并不安全，因为我们在第1章中所说的事件时间偏差的可变性：只要偏差保持小于所选处理时间延迟，缺少数据的结果将是正确的，但是任何时候偏差超过该延迟，它们将突然变得不正确。从这个角度来看，事件时间水印是许多必须推断输入中缺少数据（例如外连接，异常检测等）的实际流用例的关键部分。

现在，话虽如此，这些水印示例也突出了水印（和任何其他完整性概念）的两个缺点，具体而言，它们可能是以下两者之一：

- 太慢

  当任何类型的水印由于已知的未处理数据（例如由于网络带宽限制而慢慢增长的输入日志）而被正确延迟时，如果仅依赖于水印推进来刺激结果，则会直接导致输出延迟。
  
  这在图2-10的左图中最为明显，由于晚到达的9为所有后续窗口的水印保留，即使这些窗口的输入数据更早地变得完整。这对于第二个窗口[12:02,12:04)尤其明显，因为从窗口第一个值发生的时间到我们看到窗口的任何结果为止，需要将近七分钟的时间。在这个例子中使用的启发式水印没有如此严重的问题（五分钟的输出），但是不要认为启发式水印永远不会受到水印滞后的影响；这实际上只是我选择从这个特定示例中省略启发式水印的记录的结果。

  这里的重要观点如下：尽管水印提供了非常有用的完整性概念，但是从延迟的角度来看，仅依赖于完整性来产生输出通常并不理想。想象一下包含按小时或按天分组的有价值指标的仪表板。您不太可能想要等待整个小时或天才开始看到当前窗口的结果；这是使用经典批处理系统来为这些系统提供动力的痛点之一。相反，随着输入的演变和最终变得完整，看到这些窗口的结果逐渐完善会更好。

- 太快

  当启发式水印被错误地提前时，事件时间早于水印的数据可能会在一段时间后到达，从而创建延迟数据。这就是右侧示例中发生的事情：水印在观察到该窗口的所有输入数据之前就超过了第一个窗口的结束，导致输出值不正确，而是5而不是14。这个缺点严格来说是启发式水印的问题；它们的启发式性质意味着它们有时会出错。因此，仅依靠它们来确定何时实现输出是不足的，如果您关心正确性。

在第1章中，我对大多数需要处理无界数据流的强有力的乱序处理用例的完整性概念提出了一些非常强烈的声明。这两个缺点——水印太慢或太快——是这些论点的基础。您只能从依赖于完整性概念的系统中获得低延迟或正确性的最佳效果。因此，对于那些想要同时拥有最佳效果的情况，一个人该怎么办？如果重复的更新触发器提供低延迟更新但没有关于完整性的推理方式，而水印提供关于完整性的概念但具有可变且可能具有高延迟的特性，那么为什么不将它们的力量结合起来呢？
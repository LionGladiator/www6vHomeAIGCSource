---
title: 缓存(cache)机制
date: 2017-12-07 09:58:48
tags:
  - cache
  - 中间件
categories:
  - 分布式 
  - 中间件  
  - 缓存    
---
                               
## 缓存数据分布模式
##### 1. 分片模式 （sharding）
数据正交分散到大量机器， 可以做到线性的可伸缩性， 但是实现可用性比较困难。还有一个好处是可以通过集群做负载均衡来实现数据的管理。 
根据CAP理论， 在高可用的场景下， 数据分区的容忍性需要牺牲一定的一致性。 相应各个副本的同步策略也有不同， 主要可分为同步和异步方式。由客户端做一致性hash把数据分片存放到服务端。
   
##### 2. 复制模式
数据在集群中存在多个副本。 在本地缓存的集群中，数据会复制到所有的节点中，没有网络延迟和等待时间的集群成员都是可用的。 多副本通过低延迟访问来提供高性能。
在修改数据时需要复制新的版本数据到所有的副本， 在高并发修改的场景下会限制系统的可伸缩性， 副本数不会调的太高。

<!-- more -->   
 
## 本地缓存
 
   在同一机房内的， 需要适量考虑本地cache， 数据压缩传输等以节省内网数据传输量 。
跨机房的缓存有地域区分，用户往往访问同一机房， 这样可以做本地的cache。 机房之间通过队列的方式进行异步和压缩传输，以提高用户请求的相应度。
 
##### 过期策略：
##### 1.      被动过期 （一致性低， 缓存超时）
对一致性要求较低的系统，可以采用常规的缓存超时策略，此类策略属于被动过期。
存放数据时，永不过期的数据不要与有过期策略的数据放在一起， 早期的版本memcache曾经有一个这样的bug， 永不过期的数据被有过期策略的数据踢走了。不要把所有的数据的过期时间设为同一个时间， 这样可能造成大规模的数据同时过期，hit rate变小， 对数据库的查询数瞬时变大，造成数据库的压力。 
 
##### 2.      主动过期（一致性高， 事件过期， 异步过期，  变化事件）
对一致性要求较高的系统，可以采用事件过期策略，此类策略属于主动过期。
      某个组件的结构发生变化，或者某个业务对象状态发生变化，把组件id或业务对象id放入过期队列中， 缓存节点异步读取这些数据， 将对应cache的对象移除。亦可把变化封装成事件放入过期队列中， 由代理处理这个事件， 异步的移除相应的缓存。         
 
##### 3. 基于版本的过期方式
在存储空间较大的前提下，借鉴mvcc的概念，每次更改数据时增加一个副本，并带版本号元数据。 然后由一个代理定时的删除低版本的过期的数据。
 
## 服务端缓存
  
   缓存服务端常用的有memcache。 Nosql的解决方案有Redies，Redies在作为cache时往往配置为无持久化的形式 。两者数据模型都是key-value的。 Redies比老牌的memcache能提供更好的性能， 更快的速度。 Memcache 没有自建的replicaion 机制, 可靠性需要在客户端以双写支持。 Redies可以看成自带持久化机制的Write-back缓存，在write-behind缓存中，数据的读取和更新通过缓存进行，与write-through缓存不同，更新的数据并不会立即持久化。相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到外部存储中， 在Redies中这种机制叫做AOF。 
 
 
  
## 缓存分层
##### 1        边缘cache: 可用CDN实现，往往是服务器端缓存，存静态数据。
可以存Html页面， 脚本， 样式， 图片，页面片段等。
##### 2        页面级缓存： 往往是本地缓存， 数据相对动态。
##### 3    逻辑缓存:  逻辑计算结果的缓存
 
可以存储索引聚合数据，比如  BI里的数据聚合表。也可以存储耗时查询数据 ，比如搜索的结果。也可以存储业务相关数据， 比如对象模型的有向图可以整个缓存起来。在微博系统中，所有@你的微博是相对耗时， 可以 考虑作为逻辑缓存。
 
##### 4． 数据源级缓存： 缓存数据源结果集
 
比如Hibernate缓存中的QueryCache用来缓存查询语句, 及查询结果集中对象的Id与Type. 当再次使用已缓存的Query时, 就可以通过对象的Id与Type在二级缓存中查找实际的对象.
 
Hibernate提供了短生命周期的缓存， 也叫事务级别的缓存。长生命周期的缓存，也叫应用级别的缓存。
 
  缓存分层之间的失效方式： 1. 映射关系  2. 日志 ＋ 重试
 
## 缓存对象的粒度  
 
有一种缓存的误用是缓存大量的数据集合，而读取其中一部分。 在很多时候，我们往往会缓存一个对象的集合，但是，我们在读取的时候，只是每次读取其中一部分。 在更新缓存时， 读出整个集合， 改变其中一部分后， 在存回去， 这样序列化与反序列化的代价相当大。
 
针对这个情况， jboss cache提供了两种粒度的对象存储：核心缓存（粗粒度的），POJO 缓存（细粒度的）。
 
核心缓存会直接把您传递给它的数据存储在一个树型结构中。键／值对被存储在树的节点上，出于复制或持续性的需要它们都被序列化了。
 
POJO 缓存则采用比较复杂的机制——利用字节码编织来内省（introspecting）用户类，并向用户类的域添加侦听器，一旦域值有任何变化，侦听器会立刻 通知缓存。例如，如果要在POJO缓存中存储一个庞大、复杂的对象，会导致POJO缓存内省对象的字节码，最终只把该对象的原始域存储到树结构中。一旦域 值有所变化，缓存只复制这个改变了的域值而不会去复制整个用户类，这是高效的细粒度复制。
 
在缓存了细粒度的对象后， 造成的一个问题是数据的冗余。 例如查询条件1的返回的是model1, model2, model3, 查询条件2返回的是model2, model3, model4. model2, model3在缓存里就存了两份， 造成了冗余。这时可以分离出一个索引层，索引层存储缓存对象的地址， 这样可以节约大量的存储空间。 例如可以存储model1- model4的索引， 再从缓存中取得到实际的model.  在数据库中， 这种方式叫look up table. 如果系统更复杂， 可以采取缓存的partition加多级索引的方式。
 
 
 
 
## 缓存与一致性
 
  缓存多副本之间的同步：
  可分为replication和invalidaiton机制。 Replication机制表示一旦有数据的更新， 其余副本都会同步复制一份更新后的数据。Replication机制复制时slave会对master节点有拖累， 这时可以考虑采取invalidation机制。 Invalidation机制在jboss cache里已有实现, 一旦有更新， 广播消息， 失效所有其他的副本，让其重新去获得该值。 可通过这种方式缓存大对象以减少在实例中复制对象的代价。根据用户在一定时间段内上网地点固定不变的规律，用户始终都是访问同一个机房， 针对主节点的本地缓存在有更新时可以异步发invalidation消息，副本节点可以慢慢的再加载回这个大对象， 这样可以提高用户响应度。这种方式也可用在边缘缓存中。对于无法分组的数据， 比如在某时间段的用户认证数据需要保证副本同步，最好的方式是清除相应的副本， 让它在下次使用时初始化。 
  
 
## 缓存与数据库的数据同步
 
  在应用层， 可以根据业务场景对一致性的要求不同， 给数据分配不同的队列，即
一致性分级队列。 强一致性的场景如自己发布的评论， 自己应该及时看到。 而别人看到我的评论属于会话一致性， 一致性要求比较弱。 这样可以把一致性要求高的业务分配更多资源， 做到快速同步。   
  缓存与数据库同步的异步化也是提高响应度的方式， 在write-behind的方式中，所有的数据的操作都在缓存中， 更新的数据并不会立即传到数据库。相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到数据库中。
 
  在DAO层的hibernate针对一致性的要求提出了类似DBMS的事务级别的4个配置项。 非严格读写型(nonstrict-read-write)策略提供弱一致性，不保证缓存与数据库中数据的一致性。如果存在两个事务同时访问缓存中相同数据的可能，必须为该数据配置一个很短的数据过期时间，从而尽量避免脏读。对于极少被修改，并且允许偶尔脏读的数据，可以采用这种并发访问策略。 事务策略(transactional )只可用于托管环境，如有必要，它还保证完全的事务隔离级别直到可重复读。事务策略可以用在强一致性的场景中。
 
 
## 缓存与场景
##### 1. 非共性数据缓存 eg. 微博， 博客个人首页
  问题：缓存所有的数据性价比不高，　命中率不高
  解决方案：
##### I.                   热点缓存。
  只缓存那些热点的数据。可以缓存在线的用户，　缓存热销的商品，　缓存热点用户的数据。热点规则表示如何匹配到一个热点，即这个查询请求是否请求了热点数据。 根据2/8原则，小部分的数据占用了大部分的访问量。 这也就是twitter  page cache  是40%，而不是90%的原因。
　
##### II.  非热点数据，
  
  可以采用nosql技术（redies），可以把它看成可持久化的缓存。
   原理类似虚拟内存，理论上不受内存大小的限制。使用NoSQL来做缓存，我们可以把一些不常访问、不怎么更新的数据也缓存起来。比如论坛、新闻的老数据、数据列表的靠后的页面，虽然用户访问不多，但是搜索引擎爬虫会访问，也可能导致系统负载上升。
  从外存拿数据减少了计算的开销 ，由于其数据库结构的简单，从磁盘获取一次数 据也比从数据库一次耗时的查询划算很多。
 
##### III. read-only缓存
   缓存是read-only的， 如果有cache数据的更新， 把cache置为失效的。 如果有多个副本，这样做能够减少replication更新数据的开销， 只需要发送置失效的消息即可。
 
 
##### 2. 高并发更新场景
 
##### I. 悲观锁方案：
高并发更新， 缓存会超时的场景可以使用mutex锁。如
首页top 10, 由数据库加载到memcache缓存n分钟
微博中名人的content cache, 一旦不存在会大量请求不能命中并加载数据库
在加载数据库之前先增加一个mutex key作为锁， 成功之后再去做加载数据库， 如果加锁失败则sleep，之后重试读取原cache数据。为了防止死锁，锁也需要设置过期时间。
 
##### II. 乐观锁方案：
 
MVCC是后验性的，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突，由于没有锁，所以读写不会相互阻塞，从而大大提升了并发性能。修改过的副本带着版本号元数据， 多个副本在合并时， 根据版本检测冲突， 并合并数据。
 
Memcache 通过客户端cas命令实现乐观锁。 Jboss在3.0实现了mvcc。 MVCC 提供了非阻塞 (non-blocking) 读操作 ( 它并不会去阻塞 wirter threads) ，在避免死锁的同时也提供了更高级的并发机制。它采用了 fail-fast 机制，如果写操作得到了一个 write lock ，那么它们也是依次进行，不允许重叠。
   
## Redies作为缓存的最佳实践
   1. 对于全局公用的，构建成本比较低的数据， 可以采用一致性hash， 无复制， 无持久化的方案。 如果缓存crash了，可以快速重新构建。
   2. 对于与用户相关的， 一致性要求比较低的， 构建成本较低的， 可以采用多对一的复制方式，多个小容量的节点复制到同一个大容量的节点， 但不提供持久化， 提供较高的可用性。
   3. 对于与用户相关的，一致性要求比较高的， 构建成本比较高，但存储占用量不高的场景下， 需要持久化， 并且一对一的复制方式， 提供最高的可用性。
 
 
> **案例： Twitter缓存体系**
  Twitter: 
     逻辑缓存  
        －  page cache    api
        － fragment cache    1. 原始数据的冗余 2. 结构上的冗余
     数据源cache 
        － vector cache
        － Row cache 
+ Page， fragment － 全局与局部的分离， api， 业务逻辑
+ Vector, row cache – 索引与内容的分离
+ Google gfs cache


> **缓存类型：**
   Read-through  读贯穿
   Write-trrough  写贯穿
   Write-behind
 
## Reference:
1. [NoSQL架构实践（三）——以NoSQL为缓存](http://www.infoq.com/cn/news/2011/03/nosql-architecture-practice-3) 
2. [大型网站架构系列之五,缓存策略设计概要](http://wenku.baidu.com/view/018e3f2d7375a417866f8fbc.html?)
3. [Memcache mutex设计模式](http://timyang.net/programming/memcache-mutex/?) 
4. [深入理解JBoss Cache3.0——Naga](http://superleo.iteye.com/blog/265823?) 
5. [极端事务处理模式：Write-behind缓存](http://www.infoq.com/cn/articles/write-behind-caching?) 
6. [Memcache mutex设计模式](http://timyang.net/programming/memcache-mutex/?) 
7. [多版本并发控制(MVCC)在分布式系统中的应用](http://coolshell.cn/articles/6790.html) 





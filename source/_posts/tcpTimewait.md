---
title: TIME_WAIT和优化
date: 2020-08-09 12:03:41
tags: 
  - 网络
categories: 
  - linux
  - 网络
  - TCP     
---

<p></p>
<!-- more -->

## 目录
<!-- toc -->

## 故障现象
让我们先从一例线上故障说起。在一次升级线上应用服务之后，我们发现该服务的可用性变
得时好时坏，**一段时间可以对外提供服务，一段时间突然又不可以，** 大家都百思不得其解。
运维同学登录到服务所在的主机上，使用 netstat 命令查看后才发现，主机上有成千上万处
于 TIME_WAIT 状态的连接。

经过层层剖析后，我们发现罪魁祸首就是 TIME_WAIT。为什么呢？我们这个应用服务需要
通过发起 TCP 连接对外提供服务。**每个连接会占用一个本地端口，当在高并发的情况下，
TIME_WAIT 状态的连接过多，多到把本机可用的端口耗尽，应用服务对外表现的症状，就
是不能正常工作了。当过了一段时间之后，处于 TIME_WAIT 的连接被系统回收并关闭
后，释放出本地端口可供使用，应用服务对外表现为，可以正常工作。这样周而复始，便会
出现了一会儿不可以，过一两分钟又可以正常工作的现象。**

##  TIME_WAIT概念和作用

###  概念
+ **只有发起连接终止的一方会进入 TIME_WAIT 状态**。
+ **TIME_WAIT**停留持续时间是固定的，是最长分节生命期 MSL（maximumsegment lifetime）的两倍（**2MSL**）。Linux系统里有一个硬编码的字段，名称为TCP_IMEWAIT_LEN，其值为 60 秒。也就是说，**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。

###  作用
+ 这样做是为了**确保最后的 ACK 能让被动关闭方接收**（可能丢失ACK后**重传ACK**），从而帮助其**正常关闭**。
+ 第二个理由和连接“化身”和报文迷走有关系，为了让旧连接的重复分节在网络中自然消失。

##  TIME_WAIT的副作用和优化

###  TCP和TIME_WAIT

当连接的一方主动关闭连接，在接收到对端的 FIN 报文之后，**主动关闭连接的一方**会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。

**主动关闭连接的一方可以是客户端，也可以是服务端；**
**副作用1 主动关闭连接的一方 是客户端；**
**副作用2 主动关闭连接的一方 是服务端；**

###  副作用和优化

+ 副作用1 **对端口资源的占用，一个 TCP 连接至少消耗一个本地端口**

+  副作用1 优化
 **net.ipv4.tcp_tw_reuse（推荐）**
  从协议角度理解如果是安全可控的，可以**复用**处于 TIME_WAIT 的套接字为新的**连接**所用.
  1. 只适用于连接**发起方**（C/S 模型中的客户端）；
  2. 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。

 **net.ipv4.tcp_max_tw_buckets（不推荐）**
  这个值默认为 18000，当系统中处于TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置.
  这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

 **SO_LINGER（不推荐）**  
  不要试图使用SO_LINGER设置套接字选项，跳过 TIME_WAIT；


+ 副作用2  **服务器端程序重启时，地址被占用 -> Address already in use 异常**
通过服务器端发起的关闭连接操作，引起了一个已有的 TCP 连接处于 **TME_WAIT 状态**，正是这个 TIME_WAIT 的连接，使得服务器重启时，**继续绑定在127.0.0.1地址和xxxx端口上的操作**，返回了Address already in use的错误。

+ 副作用2  优化
服务器端程序，都应该设置 **SO_REUSEADDR 套接字选项**，以便服务端程序可以在极短时间内**复用同一个端口启动**。

## 参考
1. [网络编程实战 - 10 | TIME_WAIT：隐藏在细节下的魔鬼]() 盛延敏  
2. [网络编程实战 - 15 | 怎么老是出现“地址已经被使用”？]() 盛延敏  